# 微前端从实战到源码

微前端就是将不同的功能按照不同的维度拆分为多个子应用，通过主应用来加载这些子应用

### 1.微前端解决的问题

- 不同团队，同时开发一个应用、
- 每个团队开发的模块可以独立开发，独立部署
- 实现增量迁移

### 2.如何实现微前端

可以将一个应用划分为若干个子应用，将子应用打包为一个个的模块，当路径切换的时候加载不同的子应用，这样每个子应用都是独立的

实现微前端的技术方案

- iframe
  - 最简单的方案，通过postMessage进行通信
  - 完美的沙箱机制自带应用隔离
  - 用户体验差，弹框只在iframe之中，在内部切换状态的时候刷新就会丢失状态
- web components 特点是w3c承认的
  - 将前端应用程序分解为自定义html元素
  - 基于customEvent实现通信
  - shadow dom天生的作用于隔离
  - 缺点：浏览器支持问题，学习成本，调试困难，修改样式困难，兼容性比较差

- single-spa
  - single-spa通过路由劫持实现应用的加载systemjs，提供应用间公共组件加载以及公共业务逻辑处理，子应用需要暴露固定的钩子bootstrap,mount,unmount接入协议
  - 基于props主应用子应用之间进行通信
  - 没有沙箱机制，需要自己实现js沙箱和css沙箱
  - 缺点：学习成本，没有沙箱机制，需要对原有的应用进行改造，子应用之间相同资源重复加载了
- module federation
  - 通过模块联邦将组件进行打包导出使用
  - 共享模块的方式进行通信
  - 没有css沙箱和js沙箱
  - 缺点：需要webpack5

​	





### 3.常见问题

- 依赖复用的问题
  - 创建共享模块，独立打包部署到cdn上面，通过加载应用的时候传入，或者在子应用之中引入
  - 通过联邦模块进行打包处理公共资源
  - 两个应用之间加载资源的地址相同的话就可以复用（http的缓存模式）
- 应用之间的组件的共享的问题
  - 应用之中将共享的组件进行单独打包，加载应用的时候进行传入
- vite的支持问题
  - 基于vite构建的项目之中的import export并没有被转码，会导致直接报错，可以采用生产环境接入vite
- qiankun的嵌套的问题
  - 需要避免多重沙箱嵌套的问题，子应用之中需要关闭沙箱
  - 嵌套多层的window的代理就会错乱掉。。。 沙箱的多重嵌套
- css沙箱并不完美
  - strictStylesolation完全隔离问题，样式无法传递到子应用之中
  - experimentalStylesolation子应用dom结构插入到body之中，样式无法生效的问题

### 4.micro-app

- 对于micro-app而言，核心是创建一个micro-app的组件，就是一个webComponent组件
- 获取html 将其放到webComponent
- css就是作用的隔离 js做proxy沙箱 (function(window)with(window) {})(proxyWindow)
- 执行完毕应用后可以正常的挂载
- qiankun改造的子应用 mount unmount 以前的qiankun项目也可以接入进来
- 最后的样式肯定都是在style里面好做作用域的隔离



iframe / 路由劫持 / web Component




emp
使用了模块联邦
- 模块联邦：的动机是为了不同开发小组之间共同开发一个或者多个应用
应用将会被划分为更小的应用块，一个应用快，可以使比如头部导航或者是侧边栏的前端组件
也可以是数据获取逻辑的逻辑组件
- 每个应用块应该由不同的组开发
- 应用或者是应用块共享其他的应用块或者是库






使用模块联邦的时候，每个应用块都是一个独立的构建，这些构建都将编译为容器
容器可以被其他应用或者其他容器引用
一个被引用的容器成为remote，引用者是host，remote暴露给host
host则可以使用这些暴露的模块，这些模块被称为remote模块
























